generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified Boolean   @default(false)
  name          String?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  profile          Profile?
  qualification    Qualification?
  surveyResponse   SurveyResponse?
  sentMatches      Match[]          @relation("MatchUser1")
  receivedMatches  Match[]          @relation("MatchUser2")
  matchFeedbacks   MatchFeedback[]
  referralCode     String           @default("")
  sessions         Session[]
  accounts         Account[]
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  accountId         String
  providerId        String
  accessToken       String?
  refreshToken      String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope             String?
  idToken           String?
  password          String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Profile {
  id          String   @id @default(cuid())
  userId      String   @unique
  displayName String
  gender      String
  age         Int
  school      String
  education        String   @default("")
  schoolTier       String   @default("")
  datingPreference String   @default("")
  major            String?
  classYear   String?
  bio         String?

  // Deal-breaker system: JSON arrays of trait IDs
  traits       String @default("[]")
  dealBreakers String @default("[]")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Qualification {
  id              String   @id @default(cuid())
  userId          String   @unique
  eduEmail        String?
  eduVerified     Boolean  @default(false)
  diplomaUrl      String?
  diplomaVerified Boolean  @default(false)
  otherProof      String?
  status          String   @default("pending") // pending | verified | rejected
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model SurveyResponse {
  id     String @id @default(cuid())
  userId String @unique

  // JSON blob storing all answers: { questionId: value }
  answers String @default("{}")

  // Core values stored as comma-separated list
  coreValues String @default("")

  completed Boolean  @default(false)
  optedIn   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model HelicopterPilot {
  id          String   @id @default(cuid())
  displayName String
  createdAt   DateTime @default(now())
}

model NeptuneResponse {
  id          String   @id @default(cuid())
  displayName String
  mbti        String   @default("")
  zodiac      String   @default("")
  answers     String   @default("{}")
  createdAt   DateTime @default(now())
}

model Match {
  id              String   @id @default(cuid())
  user1Id         String
  user2Id         String
  compatibility   Float
  reasons         String   @default("[]") // JSON array of match reasons
  aiInsight       String?  // LLM-generated personalized narrative
  week            String   // e.g. "2026-W08"
  emailSentAt     DateTime?
  createdAt       DateTime @default(now())

  user1     User            @relation("MatchUser1", fields: [user1Id], references: [id])
  user2     User            @relation("MatchUser2", fields: [user2Id], references: [id])
  feedbacks MatchFeedback[]

  @@unique([user1Id, user2Id, week])
}

model MatchFeedback {
  id           String   @id @default(cuid())
  matchId      String
  userId       String

  // 短期反馈：邮件一键评分 1-5
  initialScore Int?

  // 中期反馈：进展状态
  // chatting_well | occasionally | added_no_chat | incompatible | no_response
  status       String?

  // 低分时的可选原因标签 JSON array: ["三观不合", "聊天敷衍", ...]
  issues       String   @default("[]")

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([matchId, userId])
}
